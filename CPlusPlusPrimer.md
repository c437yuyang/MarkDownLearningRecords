#C++Primier Learning Records

##第二章
###2.1
1. 无符号类型与有符号类型相加自动转换为无符号类型
2. 0X或者0x开头都可以表示16进制的数
3. 字面值是能够容纳下它的类型的最小类型，所以一般的正数字面值就是int类型，short没有对应的字面值
4. 默认的浮点型字面值都是double

###2.2
1. 定义于函数体之外的变量被初始化为0，定义于函数体内部的内置类型变量将不被初始化，是未定义的
2. 如果想要声明一个变量而不初始化，就加extern,如果后面加了赋值,extern就没用了

###2.6
1. C++11新标准规定，可以为数据成员提供类内初始值，没有初始值的成员将被默认初始化。
2. 只要写头文件就都应该加上#ifndef #define #endif 这样的头文件保护符

##第三章

###3.1
* 头文件不应该包含using声明，防止包含头文件时出现命名空间的冲突。
###3.2
* C语言中的<name.h>的头文件，c++中改为了<cname>以表明这是属于C语言的一个头文件。
###3.4
1. C++中习惯用!=是因为不是所有的容器都定义了opearator<(),但是都是定义了!=和==的，因此最好用!=
2. 使用迭代器而不是下标的原因也是类似。

###3.6数组
* 默认情况下数组的元素是默认初始化

如:

	int arr[10]; //如果是内置类型的数组，就是未定义的值

* string类型是可以直接比较的大小的
* 但const char *类型不能，需要使用strcmp


##第四章 表达式
###4.1.3求值顺序
* 没有指定执行顺序的运算符来说，如果表达式指向并修改了同一个对象，将引发错误并产生未定义的行为。
* 如:
	cout << i << ++i << endl;

###4.2算术运算符
	bool b = true;
	bool b2 = -b;
	//这时b2其实还是true,因为参与-号运算的话，先提升成整形1了，再取负成了-1，最后还是非0值

###4.4赋值运算符
* c++11新标准允许直接用初始值列表进行赋值


	//如
	vector<int> vi = {1};
	vi = {1,2,3,4}; //后面在赋值也是正确的

* 复合操作:
* ==<，>>=,&=,^=这些都是有的

###4.5递增和递减运算符
* 混用解引用和递增递减运算符
* 比如:\*++pbeg;,\*的优先级比较低，所以其实就是\*(++pbeg)
* 另一个可能出现未定义的例子：
	*beg = toupper(*beg++); //编译器无法确定先++还是直接用beg

###4.6成员访问运算符
* 解引用运算符优先级低于点运算符
* \*p.size()!=(\*p).size()

###4.8位运算
* 移位运算符满足左结合律
* 因次
	* cout << 42 + 10  等价于:
	* (cout << 42) + 10 //就是cout对象+10了
	* 应该用: cout << (42 + 10);

###4.11类型转换
* 整形提升:对于bool、char、signed char、unsigned char、short和unsigned short来说，只要他们的值能够存在int里面，就会提升成int，否则提升成unsigned int
* 运算开始，首先执行整形提升,如果类型匹配了，就直接进行运算。
* 否则如果都是带符号的或者都是无符号的，就将小的运算类型转成大的。
* 如果一个是无符号一个是有符号，且无符号>=有符号的，那么转换成无符号的

####4.11.3
1.const_cast只能改变底层const

##第六章
####6.2.3
* 顶层const在作为形参的时候可以忽略
* 其实还是那句话，就是说**const的可以处理非const的，反之不能**。
* **如果函数不会改变形参则一定要定义成const引用**，非const引用将会产生误导：可以修改，并且极大的限制所能接受的实参的类型(const类型，字面值们需要类型转换的对象)。还有就是
	* bool is_sentence(const string& s)
	* {
		* string::size_type ctr = 0;
		* return find_char(s,'.',ctr)==s.size()-1 && ctr==-1;
	* }
* 这种情况下，很难发现问题在哪里

####6.2.4
* 数组作为形参的时候，都是转为指针
* void print(const int *)
* void print(const int [])
* void print(const int [10]) //**这里限制维度不起作用**
* 这三个都是一样的
* 如果想要限制数组大小的话，可以用引用实现如:
* void print(int (&arr)[10])

####6.3.2
* **不要返回局部对象的指针或引用**
* C++11新标准支持返回列表初始化返回值
* 比如:
* vetor<string> func()
* {
*    return {"1","2","3"};
* }

##第七章
####7.1.2
* this指针本身是 T * const;类型
* const成员函数就是修饰this指针的，使之成为const T* const;
* 因此不能去修改类对象的数据成员了

####7.1.4 构造函数
* 构造函数不能声明为const的
* 不使用默认构造函数的原因:
	1. 编译器只有发现我们未定义构造函数的情况下才会生成默认构造函数
	2. 合成的默认构造函数可能执行错误的操作，比如含有内置类型(将会出现未定义的值)或者符合类型(指针或引用)(将会出现为初始化)
	3. 有些成员没有默认构造函数，则合成的默认构造函数无法完成。
* 只有当类的内置类型和复合类型成员都**有内类初始值**时才适合使用默认构造函数

####7.3.3类的声明
* class Person;
* xxxxxxxxxxxxx
* 这种前置声明只能使用在有限的场景下:
* 可以定义指向这种类型的指针或者引用，也可以声明以不完全类型作为参数或者返回类型的函数。

####7.3.4友元
* 重载函数必须分别声明为友元才行

###7.5.4隐式类型转换
* 如果构造函数只接受一个实参(或者多个实参但除了第一个都有默认实参)，则称为转换构造函数
* 发生隐式转换可能还有一种情况:
* string null\_book;
* Sales\_data item = null\_book;
* 对于explicit的构造函数，也可以显示调用，有两种方法:
	1. item.combine(Sales_data(null_book)); //显示创建临时对象
	2. item.combine(static\_cast<Sales_data\>(cin)); //用static\_cast实现，其实背后就是因为这个类就这一个成员，所以可以这样做(数据区刚好就是这些东西，一模一样)


###7.6 静态成员
* 静态成员可以是不完全类型
* 静态成员可以充当其他成员函数的默认实参